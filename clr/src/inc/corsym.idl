// ==++==
// 
//   
//    Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
//   
//    The use and distribution terms for this software are contained in the file
//    named license.txt, which can be found in the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by the
//    terms of this license.
//   
//    You must not remove this notice, or any other, from this software.
//   
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * Common Language Runtime Debugging Symbol Reader/Writer/Binder Interfaces
 * ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- *
 * Imported types
 * ------------------------------------------------------------------------- */

cpp_quote("#if 0")
typedef UINT32 mdToken;
typedef mdToken mdTypeDef;
typedef mdToken mdMethodDef;
typedef SIZE_T IMAGE_DEBUG_DIRECTORY;
cpp_quote("#endif")

/* ------------------------------------------------------------------------- *
 * Guids for known languages, language vendors, and document types
 * ------------------------------------------------------------------------- */

cpp_quote("EXTERN_GUID(CorSym_LanguageType_C, 0x63a08714, 0xfc37, 0x11d2, 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_CPlusPlus, 0x3a12d0b7, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_CSharp, 0x3f5162f8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_Basic, 0x3a12d0b8, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_Java, 0x3a12d0b4, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_Cobol, 0xaf046cd1, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_Pascal, 0xaf046cd2, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_ILAssembly, 0xaf046cd3, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_JScript, 0x3a12d0b6, 0xc26c, 0x11d0, 0xb4, 0x42, 0x00, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_SMC, 0xd9b9f7b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);")
cpp_quote("EXTERN_GUID(CorSym_LanguageType_MCPlusPlus, 0x4b35fde8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);")
cpp_quote("EXTERN_GUID(CorSym_LanguageVendor_Microsoft, 0x994b45c4, 0xe6e9, 0x11d2, 0x90, 0x3f, 0x00, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);")
cpp_quote("EXTERN_GUID(CorSym_DocumentType_Text, 0x5a869d0b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);")
cpp_quote("EXTERN_GUID(CorSym_DocumentType_MC, 0xeb40cb65, 0x3c1f, 0x4352, 0x9d, 0x7b, 0xba, 0xf, 0xc4, 0x7a, 0x9d, 0x77);")

/* ------------------------------------------------------------------------- *
 * Forward declarations
 * ------------------------------------------------------------------------- */

interface ISymUnmanagedDocument;
interface ISymUnmanagedDocumentWriter;
interface ISymUnmanagedMethod;
interface ISymUnmanagedNamespace;
interface ISymUnmanagedReader;
interface ISymUnmanagedScope;
interface ISymUnmanagedVariable;
interface ISymUnmanagedWriter;
interface ISymUnmanagedBinder;

/* ------------------------------------------------------------------------- *
 * CorSymAddrKind -- specifies the kinds of addresses used by the interfaces
 * ------------------------------------------------------------------------- */

typedef enum CorSymAddrKind
{
    /*
     * ADDR_IL_OFFSET: addr1 = IL local var or param index.
     */
    ADDR_IL_OFFSET = 1,

    /*
     * ADDR_NATIVE_RVA: addr1 = RVA into module.
     */
    ADDR_NATIVE_RVA = 2,

    /*
     * ADDR_NATIVE_REGISTER: addr1 = register the var is stored in.
     */
    ADDR_NATIVE_REGISTER = 3,

    /*
     * ADDR_NATIVE_REGREL: addr1 = register, addr2 = offset.
     */
    ADDR_NATIVE_REGREL = 4,

    /*
     * ADDR_NATIVE_OFFSET: addr1 = offset from start of parent.
     */
    ADDR_NATIVE_OFFSET = 5,

    /*
     * ADDR_NATIVE_REGREG: addr1 = reg low, addr2 = reg high.
     */
    ADDR_NATIVE_REGREG = 6,

    /*
     * ADDR_NATIVE_REGSTK: addr1 = reg low, addr2 = reg stk, addr3 = offset.
     */
    ADDR_NATIVE_REGSTK = 7,

    /*
     * ADDR_NATIVE_STKREG: addr1 = reg stk, addr2 = offset, addr3 = reg high.
     */
    ADDR_NATIVE_STKREG = 8,

    /*
     * ADDR_BITFIELD: addr1 = field start, addr = field length.
     */
    ADDR_BITFIELD = 9
} CorSymAddrKind;

/* ------------------------------------------------------------------------- *
 * Library defintion
 * ------------------------------------------------------------------------- */

[
  uuid(7E348441-7E1F-380E-A0F6-22668F0F9E4B),
  version(1.0),
  helpstring("Common Language Runtime Symbol Store 1.0 Type Library")
]
library CorSymLib
{
    importlib("STDOLE2.TLB");

        [
        uuid(108296C1-281E-11d3-BD22-0000F80849BD)
        ]
        coclass CorSymWriter
        {
                [default] interface ISymUnmanagedWriter;
        };
 
        [
        uuid(108296C2-281E-11d3-BD22-0000F80849BD)
        ]
        coclass CorSymReader
        {
                [default] interface ISymUnmanagedReader;
        };

        [
        uuid(AA544D41-28CB-11d3-BD22-0000F80849BD)
        ]
        coclass CorSymBinder
        {
                [default] interface ISymUnmanagedBinder;
        };
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedBinder interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(AA544D42-28CB-11d3-BD22-0000F80849BD),
 pointer_default(unique)
]
interface ISymUnmanagedBinder : IUnknown
{
    /*
     * Given a metadata interface and a file name, returns the
     * correct ISymUnmanagedReader that will read the debugging symbols
     * associated with the module.
     *
     * The searchPath parameter is optional.
     */
    HRESULT GetReaderForFile([in] IUnknown *importer,
                             [in] const WCHAR *fileName,
                             [in] const WCHAR *searchPath,
                             [out, retval] ISymUnmanagedReader **pRetVal);
    HRESULT GetReaderFromStream([in] IUnknown *importer,
                                [in] IStream *pstream,
                                [out,retval] ISymUnmanagedReader **pRetVal);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedDocument interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(40DE4037-7C81-3E1E-B022-AE1ABFF2CA08),
 pointer_default(unique)
]
interface ISymUnmanagedDocument : IUnknown
{
    /*
     * Return the URL for this document.
     */
    HRESULT GetURL([in] ULONG32 cchUrl,
                   [out] ULONG32 *pcchUrl,
                   [out, size_is(cchUrl),
                   length_is(*pcchUrl)] WCHAR szUrl[]);

    /*
     * Get the document type of this document.
     */
    HRESULT GetDocumentType([out, retval] GUID* pRetVal);

    /*
     * Get the language id of this document.
     */
    HRESULT GetLanguage([out, retval] GUID* pRetVal);

    /*
     * Get the language vendor of this document.
     */
    HRESULT GetLanguageVendor([out, retval] GUID* pRetVal);

    /*
     * Get the check sum algorithm id. Returns a guid of all zeros if
     * there is no checksum.
     */
    HRESULT GetCheckSumAlgorithmId([out, retval] GUID* pRetVal);

    /*
     * Get the check sum.
     */
    HRESULT GetCheckSum([in] ULONG32 cData,
                        [out] ULONG32 *pcData,
                        [out, size_is(cData),
                        length_is(*pcData)] BYTE data[]);

    /*
     * Given a line in this document that may or may not be a sequence
     * point, return the closest line that is a sequence point.  */
    HRESULT FindClosestLine([in] ULONG32 line, 
                            [out, retval] ULONG32* pRetVal);

    /*
     * Returns true if the document has source embedded in the
     * debugging symbols.
     */
    HRESULT HasEmbeddedSource([out, retval] BOOL *pRetVal);

    /*
     * Returns the length, in bytes, of the embedded source.
     */
    HRESULT GetSourceLength([out, retval] ULONG32* pRetVal);

    /*
     * Returns the embedded source into the given buffer. The buffer must
     * be large enough to hold the source.
     */
    HRESULT GetSourceRange([in] ULONG32 startLine, 
                           [in] ULONG32 startColumn, 
                           [in] ULONG32 endLine, 
                           [in] ULONG32 endColumn,
                           [in] ULONG32 cSourceBytes,
                           [out] ULONG32 *pcSourceBytes,
                           [out, size_is(cSourceBytes),
                           length_is(*pcSourceBytes)] BYTE source[]);

};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedDocumentWriter interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006),
 pointer_default(unique)
]
interface ISymUnmanagedDocumentWriter : IUnknown
{
    /*
     * Sets embedded source for a document being written.
     */
    HRESULT SetSource([in] ULONG32 sourceSize,
                      [in, size_is(sourceSize)] BYTE source[]);

    /*
     * Sets check sum info.
     */
    HRESULT SetCheckSum([in] GUID algorithmId,
                        [in] ULONG32 checkSumSize,
                        [in, size_is(checkSumSize)] BYTE checkSum[]);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedMethod interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(B62B923C-B500-3158-A543-24F307A8B7E1),
 pointer_default(unique)
]
interface ISymUnmanagedMethod : IUnknown
{
    /*
     * Return the metadata token for this method.
     */
    HRESULT GetToken([out, retval] mdMethodDef *pToken);

    /*
     * Get the count of sequence points within this method.
     */
    HRESULT GetSequencePointCount([out, retval] ULONG32* pRetVal);

    /*
     * Get the root lexical scope within this method.
     */
    HRESULT GetRootScope([out, retval] ISymUnmanagedScope** pRetVal);

    /*
     * Get the most enclosing lexical scope within this method that
     * encloses the given offset.
     */
    HRESULT GetScopeFromOffset([in] ULONG32 offset, 
                               [out, retval] ISymUnmanagedScope** pRetVal);

    /*
     * Given a position within a document, return the offset within
     * this method that cooresponds to the position.
     */
    HRESULT GetOffset([in] ISymUnmanagedDocument* document, 
                      [in] ULONG32 line, 
                      [in] ULONG32 column, 
                      [out, retval] ULONG32* pRetVal);

    /*
     * Given a position in a document, return an array of start/end
     * offset paris that correspond to the ranges of IL that the
     * position covers within this method. The array is an array of
     * integers and is [start,end,start,end]. The number of range
     * pairs is the length of the array / 2.
     */
    HRESULT GetRanges([in] ISymUnmanagedDocument* document, 
                      [in] ULONG32 line, 
                      [in] ULONG32 column,
                      [in] ULONG32 cRanges,
                      [out] ULONG32 *pcRanges,
                      [out, size_is(cRanges),
                      length_is(*pcRanges)] ULONG32 ranges[]);

    /*
     * Get the parameters for this method. The parameters are returned
     * in the order they are defined within the method's signature.
     */
    HRESULT GetParameters([in] ULONG32 cParams,
                          [out] ULONG32 *pcParams,
                          [out, size_is(cParams),
                          length_is(*pcParams)] ISymUnmanagedVariable* params[]);

    /*
     * Get the namespace that this method is defined within.
     */
    HRESULT GetNamespace([out] ISymUnmanagedNamespace **pRetVal);

    /*
     * Get the start/end document positions for the source of this
     * method. The first array position is the start while the second
     * is the end. Returns true if positions were defined, false
     * otherwise.
     */
    HRESULT GetSourceStartEnd([in] ISymUnmanagedDocument *docs[2],
                              [in] ULONG32 lines[2],
                              [in] ULONG32 columns[2],
                              [out] BOOL *pRetVal);

    /*
     * Get all the sequence points within this method.
     */
    HRESULT GetSequencePoints([in] ULONG32 cPoints,
                              [out] ULONG32 *pcPoints,
                              [in, size_is(cPoints)] ULONG32 offsets[], 
                              [in, size_is(cPoints)] ISymUnmanagedDocument* documents[], 
                              [in, size_is(cPoints)] ULONG32 lines[], 
                              [in, size_is(cPoints)] ULONG32 columns[],
                              [in, size_is(cPoints)] ULONG32 endLines[], 
                              [in, size_is(cPoints)] ULONG32 endColumns[]);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedNamespace interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(0DFF7289-54F8-11d3-BD28-0000F80849BD),
 pointer_default(unique)
]
interface ISymUnmanagedNamespace : IUnknown
{
    /*
     * Get the name of this namespace.
     */
    HRESULT GetName([in] ULONG32 cchName,
                    [out] ULONG32 *pcchName,
                    [out, size_is(cchName),
                    length_is(*pcchName)] WCHAR szName[]);

    /*
     * Get the children of this namespace.
     */
    HRESULT GetNamespaces([in] ULONG32 cNameSpaces,
                          [out] ULONG32 *pcNameSpaces,
                          [out, size_is(cNameSpaces),
                          length_is(*pcNameSpaces)]
                          ISymUnmanagedNamespace* namespaces[]);

    /*
     * Return all variables defined at global scope within this namespace.
     */
    HRESULT GetVariables([in] ULONG32 cVars,
                         [out] ULONG32 *pcVars,
                         [out, size_is(cVars),
                         length_is(*pcVars)] ISymUnmanagedVariable *pVars[]);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedReader interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5),
 pointer_default(unique)
]
interface ISymUnmanagedReader : IUnknown
{
    /*
     * Find a document. Language, vendor, and document type are optional.
     */
    HRESULT GetDocument([in] WCHAR *url, 
                        [in] GUID language, 
                        [in] GUID languageVendor, 
                        [in] GUID documentType, 
                        [out, retval] ISymUnmanagedDocument** pRetVal);

    /*
     * Return an array of all the documents defined in the symbol store.
     */
    HRESULT GetDocuments([in] ULONG32 cDocs,
                         [out] ULONG32 *pcDocs,
                         [out, size_is(cDocs),
                         length_is(*pcDocs)] ISymUnmanagedDocument *pDocs[]);

    /*
     * Return the method that was specified as the user entry point
     * for the module, if any. This would be, perhaps, the user's main
     * method rather than compiler generated stubs before main.
     */
    HRESULT GetUserEntryPoint([out, retval] mdMethodDef *pToken);

    /*
     * Get a symbol reader method given a method token.
     */
    HRESULT GetMethod([in] mdMethodDef token, 
                      [out, retval] ISymUnmanagedMethod** pRetVal);

    /*
     * Get a symbol reader method given a method token and an E&C
     * version number. Version numbers start at 1 and are incremented
     * each time the method is changed due to an E&C operation.
     */
    HRESULT GetMethodByVersion([in] mdMethodDef token,
                               [in] int version,
                               [out, retval] ISymUnmanagedMethod** pRetVal);

    /*
     * Return a non-local variable given its parent and name.
     */
    HRESULT GetVariables([in] mdToken parent, 
                         [in] ULONG32 cVars,
                         [out] ULONG32 *pcVars,
                         [out, size_is(cVars),
                         length_is(*pcVars)] ISymUnmanagedVariable *pVars[]);
    /*
     * Return all global variables.
     */
    HRESULT GetGlobalVariables([in] ULONG32 cVars,
                               [out] ULONG32 *pcVars,
                               [out, size_is(cVars),
                               length_is(*pcVars)] ISymUnmanagedVariable *pVars[]);

    /*
     * Given a position in a document, return the ISymUnmanagedMethod that
     * contains that position.
     */
    HRESULT GetMethodFromDocumentPosition([in] ISymUnmanagedDocument* document, 
                                          [in] ULONG32 line, 
                                          [in] ULONG32 column, 
                                          [out, retval] ISymUnmanagedMethod** pRetVal);

    /*
     * Gets a custom attribute based upon its name. Not to be
     * confused with Metadata custom attributes, these attributes are
     * held in the symbol store.
     */
    HRESULT GetSymAttribute([in] mdToken parent, 
                            [in] WCHAR *name,
                            [in] ULONG32 cBuffer,
                            [out] ULONG32 *pcBuffer,
                            [out, size_is(cBuffer),
                            length_is(*pcBuffer)] BYTE buffer[]);

    /*
     * Get the namespaces defined at global scope within this symbol store.
     */
    HRESULT GetNamespaces([in] ULONG32 cNameSpaces,
                          [out] ULONG32 *pcNameSpaces,
                          [out, size_is(cNameSpaces),
                          length_is(*pcNameSpaces)]
                          ISymUnmanagedNamespace* namespaces[]);

    /*
     * Initialize the symbol reader with the metadata importer interface
     * that this reader will be associated with, along with the filename
     * of the module. This can only be called once, and must be called
     * before any other reader methods are called.
     *
     * Note: you need only specify one of the filename or the pIStream,
     * not both. The searchPath parameter is optional.
     */
    HRESULT Initialize([in] IUnknown *importer,
                       [in] const WCHAR *filename,
                       [in] const WCHAR *searchPath,
                       [in] IStream *pIStream);

    /*
     * Update the existing symbol reader with a delta symbol store. This
     * is used in EnC scenarios as a way to update the symbol store to
     * match deltas to the original PE file.
     *
     * Only one of the filename or pIStream parameters need be specified.
     * If a filename is specified, the symbol store will be updated with
     * the symbols in that file. If a IStream is specified, the store will
     * be updated with the data from the IStream.
     */
    HRESULT UpdateSymbolStore([in] const WCHAR *filename,
                              [in] IStream *pIStream);

    /*
     * Update the existing symbol reader with a delta symbol
     * store. This is much like UpdateSymbolStore, but the given detla
     * acts as a complete replacement rather than an update.
     *
     * Only one of the filename or pIStream parameters need be specified.
     * If a filename is specified, the symbol store will be updated with
     * the symbols in that file. If a IStream is specified, the store will
     * be updated with the data from the IStream.
     */
    HRESULT ReplaceSymbolStore([in] const WCHAR *filename,
                               [in] IStream *pIStream);

    /*
     * Provides the on disk filename of the symbol store.
     */

    HRESULT GetSymbolStoreFileName( [in] ULONG32 cchName,
                                    [out] ULONG32 *pcchName,
                                    [out, size_is(cchName),
                                    length_is(*pcchName)]  WCHAR szName[]);

    /*
     * Given a position in a document, return the ISymUnmanagedMethods that
     * contains that position.
     */
    HRESULT GetMethodsFromDocumentPosition([in] ISymUnmanagedDocument* document, 
                                           [in] ULONG32 line, 
                                           [in] ULONG32 column,
                                           [in] ULONG32 cMethod,
                                           [out] ULONG32* pcMethod,
                                           [out, size_is(cMethod),
                                           length_is(*pcMethod)] ISymUnmanagedMethod* pRetVal[]);

    /*
     * The document version starts at 1 and is incremented each time
     * the document is updated via UpdateSymbols.     
     * bCurrent is true is this is the latest version of the document.
     */
    HRESULT GetDocumentVersion([in] ISymUnmanagedDocument *pDoc,
                               [out] int* version,
                               [out] BOOL* pbCurrent);

    /*
     * The method version starts at 1 and is incremented each time
     * the method is recompiled.  (This can happen without changes to the method.)
     */
    HRESULT GetMethodVersion([in] ISymUnmanagedMethod* pMethod,
                             [out] int* version);

};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedScope interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(68005D0F-B8E0-3B01-84D5-A11A94154942),
 pointer_default(unique)
]
interface ISymUnmanagedScope : IUnknown
{
    /*
     * Get the method that contains this scope.
     */
    HRESULT GetMethod([out, retval] ISymUnmanagedMethod** pRetVal);

    /*
     * Get the parent scope of this scope.
     */
    HRESULT GetParent([out, retval] ISymUnmanagedScope** pRetVal);

    /*
     * Get the children of this scope.
     */
    HRESULT GetChildren([in] ULONG32 cChildren,
                        [out] ULONG32 *pcChildren,
                        [out, size_is(cChildren),
                        length_is(*pcChildren)] ISymUnmanagedScope* children[]);

    /*
     * Get the start offset for this scope,
     */
    HRESULT GetStartOffset([out, retval] ULONG32* pRetVal);

    /*
     * Get the end offset for this scope.
     */
    HRESULT GetEndOffset([out, retval] ULONG32* pRetVal);

    /*
     * Get a count of the number of local variables defined within this
     * scope.
     */
    HRESULT GetLocalCount([out, retval] ULONG32 *pRetVal);

    /*
     * Get the local variables defined within this scope.
     */
    HRESULT GetLocals([in] ULONG32 cLocals,
                      [out] ULONG32 *pcLocals,
                      [out, size_is(cLocals),
                      length_is(*pcLocals)] ISymUnmanagedVariable* locals[]);

    /*
     * Get the namespaces that are being "used" within this scope.
     */
    HRESULT GetNamespaces([in] ULONG32 cNameSpaces,
                          [out] ULONG32 *pcNameSpaces,
                          [out, size_is(cNameSpaces),
                          length_is(*pcNameSpaces)]
                          ISymUnmanagedNamespace* namespaces[]);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedVariable interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB),
 pointer_default(unique)
]
interface ISymUnmanagedVariable : IUnknown
{
    /*
     * Get the name of this variable.
     */
    HRESULT GetName([in] ULONG32 cchName,
                    [out] ULONG32 *pcchName,
                    [out, size_is(cchName),
                    length_is(*pcchName)] WCHAR szName[]);

    /*
     * Get the attribute flags for this variable.
     */
    HRESULT GetAttributes([out, retval] ULONG32* pRetVal);

    /*
     * Get the signature of this variable.
     */
    HRESULT GetSignature([in] ULONG32 cSig,
                         [out] ULONG32 *pcSig,
                         [out, size_is(cSig),
                         length_is(*pcSig)] BYTE sig[]);

    /*
     * Get the kind of address of this variable
     */
    HRESULT GetAddressKind([out, retval] ULONG32* pRetVal);

    /*
     * Get the first address field for this variable. Its meaning depends
     * on the address kind.
     */
    HRESULT GetAddressField1([out, retval] ULONG32* pRetVal);

    /*
     * Get the second address field for this variable. Its meaning depends
     * on the address kind.
     */
    HRESULT GetAddressField2([out, retval] ULONG32* pRetVal);

    /*
     * Get the third address field for this variable. Its meaning depends
     * on the address kind.
     */
    HRESULT GetAddressField3([out, retval] ULONG32* pRetVal);

    /*
     * Get the start offset of this variable within its parent. If this is
     * a local variable within a scope, this fill fall within the offsets
     * defined for the scope.
     */
    HRESULT GetStartOffset([out, retval] ULONG32* pRetVal);

    /*
     * Get the end offset of this variable within its parent. If this is
     * a local variable within a scope, this fill fall within the offsets
     * defined for the scope.
     */
    HRESULT GetEndOffset([out, retval] ULONG32* pRetVal);
};

/* ------------------------------------------------------------------------- *
 * ISymUnmanagedWriter interface
 * ------------------------------------------------------------------------- */

[
 object,
 uuid(2DE91396-3844-3B1D-8E91-41C24FD672EA),
 pointer_default(unique)
]
interface ISymUnmanagedWriter : IUnknown
{
    /*
     * Define a source document. Guid's will be provided for languages,
     * vendors, and document types that we currently know about.
     */
    HRESULT DefineDocument([in] const WCHAR *url, 
                           [in] const GUID *language, 
                           [in] const GUID *languageVendor, 
                           [in] const GUID *documentType, 
                           [out, retval] ISymUnmanagedDocumentWriter** pRetVal);

    /*
     * Define the method that the user has defined as their entrypoint
     * for this module. This would be, perhaps, the user's main method
     * rather than compiler generated stubs before main.
     */
    HRESULT SetUserEntryPoint([in] mdMethodDef entryMethod);

    /*
     * Open a method to emit symbol information into. The given method
     * becomes the current method for calls do define sequence points,
     * parameters and lexical scopes. There is an implicit lexical
     * scope around the entire method. Re-opening a method that has
     * been previously closed effectivley erases any previously
     * defined symbols for that method.
     *
     * There can be only one open method at a time.
     */
    HRESULT OpenMethod([in] mdMethodDef method);

    /*
     * Close the current method. Once a method is closed, no more
     * symbols can be defined within it.
     */
    HRESULT CloseMethod();

    /*
     * Open a new lexical scope in the current method. The scope
     * becomes the new current scope and is effectivley pushed onto a
     * stack of scopes. startOffset is the offset, in bytes from the
     * beginning of the method, of the first instruction in the
     * lexical scope. Scopes must form a hierarchy. Siblings are not
     * allowed to overlap.
     *
     * OpenScope returns an opaque scope id that can be used with
     * SetScopeRange to define a scope's start/end offset at a later
     * time. In this case, the offsets passed to OpenScope and
     * CloseScope are ignored.
     *
     * Note: scope id's are only valid in the current method.
     */
    HRESULT OpenScope([in] ULONG32 startOffset, 
                      [out, retval] ULONG32* pRetVal);

    /*
     * Close the current lexical scope. Once a scope is closed no more
     * variables can be defined within it. endOffset points past the
     * last instruction in the scope.
     */
    HRESULT CloseScope([in] ULONG32 endOffset);

    /*
     * Define the offset range for a given lexical scope.
     */
    HRESULT SetScopeRange([in] ULONG32 scopeID, 
                          [in] ULONG32 startOffset, 
                          [in] ULONG32 endOffset);

    /*
     * Define a single variable in the current lexical
     * scope. startOffset and endOffset are optional. If 0, then they
     * are ignored and the variable is defined over the entire
     * scope. If non-zero, then they must fall within the offsets of
     * the current scope. This can be called multiple times for a
     * variable of the same name that has multiple homes throughout a
     * scope. (Note: start/end offsets must not overlap in such a
     * case.)
     */
    HRESULT DefineLocalVariable([in] const WCHAR *name, 
                                [in] ULONG32 attributes,
                                [in] ULONG32 cSig,
                                [in, size_is(cSig)] unsigned char signature[],
                                [in] ULONG32 addrKind, 
                                [in] ULONG32 addr1, 
                                [in] ULONG32 addr2, 
                                [in] ULONG32 addr3, 
                                [in] ULONG32 startOffset, 
                                [in] ULONG32 endOffset);

    /*
     * Define a single parameter in the current method. The type of
     * each parameter is taken from its position (sequence) within the
     * method's signature.
     *
     * Note: if parameters are defined in the metadata for a given
     * method, then clearly one would not have to define them again
     * with calls to this method. The symbol readers will have to be
     * smart enough to check the normal metadata for these first then
     * fall back to the symbol store.
     */
    HRESULT DefineParameter([in] const WCHAR *name, 
                            [in] ULONG32 attributes, 
                            [in] ULONG32 sequence, 
                            [in] ULONG32 addrKind, 
                            [in] ULONG32 addr1, 
                            [in] ULONG32 addr2,
                            [in] ULONG32 addr3);

    /*
     * Define a single variable not within a method. This is used for
     * certian fields in classes, bitfields, etc.
     */
    HRESULT DefineField([in] mdTypeDef parent, 
                        [in] const WCHAR *name, 
                        [in] ULONG32 attributes,
                        [in] ULONG32 cSig,
                        [in, size_is(cSig)] unsigned char signature[], 
                        [in] ULONG32 addrKind, 
                        [in] ULONG32 addr1, 
                        [in] ULONG32 addr2,
                        [in] ULONG32 addr3);

    /*
     * Define a single global variable.
     */
    HRESULT DefineGlobalVariable([in] const WCHAR *name, 
                                 [in] ULONG32 attributes,
                                 [in] ULONG32 cSig,
                                 [in, size_is(cSig)] unsigned char signature[], 
                                 [in] ULONG32 addrKind, 
                                 [in] ULONG32 addr1, 
                                 [in] ULONG32 addr2,
                                 [in] ULONG32 addr3);

    /*
     * Close will close the ISymUnmanagedWriter and commit the symbols
     * to the symbol store. The ISymUnmanagedWriter becomes invalid
     * after this call for further updates.
     */
    HRESULT Close();

    /*
     * Defines a custom attribute based upon its name. Not to be
     * confused with Metadata custom attributes, these attributes are
     * held in the symbol store.
     */
    HRESULT SetSymAttribute([in] mdToken parent, 
                            [in] const WCHAR *name,
                            [in] ULONG32 cData,
                            [in, size_is(cData)] unsigned char data[]);

    /*
     * Opens a new namespace. Call this before defining methods or
     * variables that live within a namespace. Namespaces can be nested.
     */
    HRESULT OpenNamespace([in] const WCHAR *name);

    /*
     * Close the most recently opened namespace.
     */
    HRESULT CloseNamespace();

    /*
     * Specifies that the given, fully qualified namespace name is
     * being used within the currently open lexical scope. Closing the
     * current scope will also stop using the namespace, and the
     * namespace will be in use in all scopes that inherit from the
     * currently open scope.
     */
    HRESULT UsingNamespace([in] const WCHAR *fullName);

    /*
     * Specifies the true start and end of a method within a source
     * file. Use this to specify the extent of a method independently
     * of what sequence points exist within the method.
     */
    HRESULT SetMethodSourceRange([in] ISymUnmanagedDocumentWriter *startDoc,
                                 [in] ULONG32 startLine,
                                 [in] ULONG32 startColumn,
                                 [in] ISymUnmanagedDocumentWriter *endDoc,
                                 [in] ULONG32 endLine,
                                 [in] ULONG32 endColumn);

    /*
     * Sets the metadata emitter interface that this writer will be
     * associated with. Also sets the output filename of where the
     * debugging symbols will be written. This can only be called once,
     * and must be called before any other writer methods are called.
     *
     * Some writers may require a filename, while others may not. A
     * filename can always be passed to this method, however, with
     * no ill effects on writers that do not use it.
     *
     * The pIStream parameter is optional. If specified, the symbol
     * writer will emit the symbols into the given IStream rather than
     * to the file specified in filename.
     *
     * The fFullBuild parameter indicates to the symbol writer whether
     * this is a full build or an incremental build.
     */
    HRESULT Initialize([in] IUnknown *emitter,
                       [in] const WCHAR *filename,
                       [in] IStream *pIStream,
                       [in] BOOL fFullBuild);

    /*
     * Returns the necessary info for a compiler to write the
     * necessary debug directory entry into the PE header.
     *
     * pIID should point to a IMAGE_DEBUG_DIRECTORY that the symbol
     * writer will fill out. All fields except for TimeDateStamp and
     * PointerToRawData will be filled out by the symbol writer. (The
     * compiler is responsible for setting TimeDateStamp and
     * PointerToRawData appropiatley.)
     *
     * data should point to a buffer large enough to hold the debug
     * data for the symbol store.
     *
     * A compiler should call this method, then emit the data blob to
     * the PE file and set the PointerToRawData field in the
     * IMAGE_DEBUG_DIRECTORY to point to the emitted data. Then, the
     * IMAGE_DEBUG_DIRECTORY should be written to the PE file. The
     * compiler should also set the TimeDateStamp field to equal the
     * TimeDateStamp of the PE file being generated.
     */
    HRESULT GetDebugInfo([in, out] IMAGE_DEBUG_DIRECTORY *pIDD,
                         [in] DWORD cData,
                         [out] DWORD *pcData,
                         [out, size_is(cData),
                         length_is(*pcData)] BYTE data[]);

    /*
     * Define a group of sequence points within the current method.
     * Each line/column defines the start of a statement within a
     * method. Each end line/column defines the end of a statement
     * with a method. (End line/column is optional.) The arrays should
     * be sorted by offset. The offset is always the offset from the
     * start of the method, in bytes.
     */
    HRESULT DefineSequencePoints([in] ISymUnmanagedDocumentWriter* document,
                                 [in] ULONG32 spCount,
                                 [in, size_is(spCount)] ULONG32 offsets[], 
                                 [in, size_is(spCount)] ULONG32 lines[], 
                                 [in, size_is(spCount)] ULONG32 columns[],
                                 [in, size_is(spCount)] ULONG32 endLines[], 
                                 [in, size_is(spCount)] ULONG32 endColumns[]);

    /*
     * This method tells the symbol writer that a metadata token has
     * been remapped as the metadata was emitted. If the symbol writer
     * has stored the old token within the symbol store, it must
     * either update the stored token to the new value, or persist the
     * map for the corresponding symbol reader to remap during the
     * read phase.
     */
    HRESULT RemapToken([in] mdToken oldToken,
                       [in] mdToken newToken);

    /*
     * Same as Initialize except that the final path name is the path string to 
     * name the final location of the pdb file. This is used in build enviroments in
     * which the pdb is built in a temporary location and moved when the build is
     * complete.
     */
    HRESULT Initialize2([in] IUnknown *emitter,
                   [in] const WCHAR *tempfilename,
                   [in] IStream *pIStream,
                   [in] BOOL fFullBuild,
                   [in] const WCHAR *finalfilename);

    /*
     * Defines a name for a constant value.
     */
    HRESULT DefineConstant( [in] const WCHAR *name,
                            [in] VARIANT value,
                            [in] ULONG32 cSig,
                            [in, size_is(cSig)] unsigned char signature[]);

};

